--------------------------------------------------------------------------------
-- Revised version
-- This version of program is revised based on Alf's early version
-- This version is used for the interface of lua version vid2img
-- See README for more information
-- Jarvis Du
-- Alfredo Canziani, Apr 16
--------------------------------------------------------------------------------

-- Early version statement below
--------------------------------------------------------------------------------
-- This script automatically loads the dataset generated by the user via the
-- Matlab script and video capturing the interested object
-- Alfredo Canziani
-- November 2013
--------------------------------------------------------------------------------

-- Requires --------------------------------------------------------------------
require 'pl'
require 'sys'
require 'image'
require 'xlua'

-- Parsing the command line ----------------------------------------------------
if not opt then
   print '==> Parsing the command line'
   opt = lapp [[
--classes  (default ask)        list the classes you'd like to load, or choose <all>
--nbImgs   (default 1000)       number of patches
--outSize  (default 224)        output size of patches
--outDir   (default ../Patches) ouput folder for patches
]]
end

-- The classical <ls> function, outputs table
function ls(path)
   return sys.split(sys.ls(path), '\n')
end

-- A Gaussian distributed random variable
function math.randn()
   return torch.randn(1)[1]
end

-- Loads the dataset specified
function cropPatch(class, l)
   print('==> Loading class ' .. class)

   -- Gathering information about the dataset's images
   print '==> Loading labels'
   local images = {} -- Images information: name, x, y, w, h
   local availableIstances = ls('../labels/' .. class)
   for _, labelFile in ipairs(availableIstances) do
      print('     + from ' .. labelFile)
      local fileID = io.open('../labels/' .. class .. '/' .. labelFile)
      local line
      for i = 1,2 do line = fileID:read() end -- skipping first line (header)
      while line ~= nil do
         table.insert(images, sys.split(line, ','))
         line = fileID:read()
      end
      fileID:close()
   end

   -- Create output folder
   local outDir = opt.outDir .. class
   paths.mkdir(outDir)

   -- Extracting dataset images from dumpend video's frames
   print '==> Extracting training and testing samples'
   local std = 10
   local fullBatches = math.floor(opt.nbImgs / #images)
   local batch = 0
   local idx
   for n = 1, opt.nbImgs do
      xlua.progress(n, opt.nbImgs)

      -- Batches management
      if batch < fullBatches then
         idx = n - batch * #images
      else
         idx = 1 + math.floor((#images - 1)/(opt.nbImgs - 1 - fullBatches * #images) * (n - fullBatches * #images - 1) + .5)
      end
      if n % #images == 0 then batch = batch + 1 end

      -- Extracting information from image and its label
      -- print(images[idx][1]) -- DEBUG
      local img = image.load('../images/' .. class .. '/' .. images[idx][1])

      -- print(collectgarbage("count")*1024) -- DEBUG
      collectgarbage() -- mandatory! otherwise there will be a PANIC allocation of memory by Lua

      local imgH = (#img)[2]
      local imgW = (#img)[3]
      -- print(imgH,imgW) -- DEBUG
      local s = 1
      local x = math.floor(images[idx][2] * s + math.randn() * std + .5)
      local y = math.floor(images[idx][3] * s + math.randn() * std + .5)
      local w = math.floor(images[idx][4] * s + math.randn() * std + .5)
      local h = math.floor(images[idx][5] * s + math.randn() * std + .5)
      -- print(s,x,y,w,h) -- DEBUG

      local width = math.max(w, h)
      local height = width

      -- Computing cropping coordinates
      local xA = x + math.floor(w/2) - math.floor(width/2)
      local xB = x + math.floor(w/2) + math.floor(width/2)
      local yA = y + math.floor(h/2) - math.floor(height/2)
      local yB = y + math.floor(h/2) + math.floor(height/2)
      --print(xA,xB,yA,yB,xB-xA+1,yB-yA+1) -- DEBUG

      if xA < 0 then xA = 0; xB = width end
      if yA < 0 then yA = 0; yB = height end
      if xB > imgW then xB = imgW; xA = imgW - width end
      if yB > imgH then yB = imgH; yA = imgH - height end

      local data = image.scale(image.crop(img, xA, yA, xB, yB), opt.outSize)
      --win = image.display{image=data, win=win} -- DEBUG
      image.savePNG(string.format('%s/%04d.png', outDir, n), data)
   end
end

-- Main program ----------------------------------------------------------------

-- Iteratively loads all specified datasets or asks, if so desired
local availableClasses = ls('../labels/')
local l = 1
if (opt.classes == 'all') or (opt.classes == 'ask') then -- Loads all or asks for it
   for _, class in ipairs(availableClasses) do
      if opt.classes == 'ask' then
         io.write('Would you like to load ' .. class .. ' (y/[n])? ')
         if io.read() == 'y' then
            cropPatch(class, l)
            l = l + 1
         end
      else
         cropPatch(class, l)
         l = l + 1
      end
   end
else -- Users specifies what to load from command line
   for class in string.gmatch(opt.classes, '%a+') do
      cropPatch(class, l)
      l = l + 1
   end
end
